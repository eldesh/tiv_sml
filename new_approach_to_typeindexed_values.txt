* http://mlton.org/pipermail/mlton-user/2006-September/000916.html

[MLton-user] a new approach to type-indexed values in SML
Stephen Weeks sweeks at sweeks.com
Thu Sep 28 15:58:59 PDT 2006

    Previous message: [MLton-user] profiling timer expired?
    Next message: [MLton-user] a new approach to type-indexed values in SML
    Messages sorted by: [ date ] [ thread ] [ subject ] [ author ]

Ever since Vesa posted the page on type-indexed values

  http://mlton.org/TypeIndexedValues

I've been thinking about how to define type-indexed values in a more
modular/extensible way, closer to how Haskell type classes are done.
The lack of first-class polymorphism in SML might make it seem
impossible, but I've come up with an approach that I am happy with and
I think will be useful in practice, once the initial infrastructure is
digested.
一度最初のインフラがこなれてくれば実践で役に立つだろうと思う。

The following note describes the approach.  I would be
happy to answer questions or take feedback.
以下のノートはそのアプローチを解説する。
質問やフィードバックは歓迎する。

----------------------------------------------------------------------

A type-indexed value (tiv) is a set of values with one value for each
type in a particular set of types.
tivとは型の特性セット内の、一つの値を持つ各型の集合である。

A familiar example is equality,
which can be viewed as a set of equality functions, one for each
(equality) type.
なじみのある例として等価性があり、これは各型についての 等価性関数の集合として見ることが出来る。

Many type-indexed values can be defined by induction
over type constructors.
多くのtivが型コンストラクタ上のinductionによって定義することが出来る。

For example, equality can be defined by
primitive notions of equality at ground types (bool, int, etc.) and by
induction at compound types (options, lists, tuples, etc.).
例えば、等価性は基盤型(bool, int, etc.)の等価性のプリミティブな考えと複合型
(options, lists, tuples, etc.)のinductionによって定義することが出来る。

This note shows a method to define tivs within SML that has the
following properties:
このノートは以下のような性質を持つtivをSML内で定義する手法を示す。

  * There is a single representation of types as values and a
    one-to-one correspondence between the SML type "t" and its
    representation as a value of type "t Type.t".  Here are some
    example values representing types.
	型には値としての単一の表現があり、SMLの型 "t" とその 型 "t Type.t" の値としての表現の間には
	１対１対応がある。
	以下は型を表現する値のいくつかの例である。

      BoolTycon.ty: bool Type.t
      ListTycon.ty BoolTycon.ty: bool list Type.t
      ArrowTycon.ty (IntTycon.ty, BoolTycon.ty): (int -> bool) Type.t

  * A tiv is a polymorphic function from (the representation of) types
    to an ordinary SML value of the appropriate type.
	tivは型(の表現)から対応する型の通常のSMLの値への多相関数である。
	For example,
    equality has the following specification:
	例えば、等値性は以下のような仕様を持つ。

      val equals: 'a Type.t -> 'a * 'a -> bool

  * Users of tivs are statically prevented from making type errors.
    tivのユーザは型エラーを静的に防がなければならない。
    For example, the following is a type error.
	例えば以下は型エラーである。

      equals BoolTycon.ty (13, 14)

  * A new type constructor of any arity can be defined at any 
    toplevel-declaration point in the program, and can subsequently be
    used to define tivs.
	任意のアリティの新たな型コンストラクタはプログラムの任意のトップレベルで定義することが出来、
	それに続いてtivを定義するのに使うことが出来る。

  * Type constructors for mutable types (array, ref, etc.) and
    recursive types (list) are supported as well as type constructors
    for nonrecursive immutable types (option) and ground types (bool,
    int, etc.).
	変更可能な型(array, ref, etc.)や再帰型(list)は非再帰、変更不能な型(option)と基盤型(bool, int, etc.)
	のようにサポートされている。

  * A new tiv can be declared at any toplevel-declaration point
    in the program. 
	新たなtivは任意の場所で～(前に言ったな？

  * A tiv is inductively defined over type constructors by a global
    collection of rules, with at most one rule for each type
    constructor. 
	tivは、それぞれの型コンストラクタのルールを伴う
	グローバルなルールコレクションによって型コンストラクタ上で帰納的に定義される。

  * The inductive rule for a particular tiv and a particular type
    constructor can be given at any toplevel-declaration point in the
    program after the tiv and type constructor have been defined.
	特定のtivと特定の型コンストラクタについての帰納ルールはプログラム上のトップレベル定義ポイントの
	とこでも与えることが出来る。tivと型コンストラクタが定義された後なら。

	In particular, one need neither group together all the rules for a
    tiv nor group together all the rules for a type constructor.
	特に、あるtivについての全てのルールをグループ化する必要も、
	ある型コンストラクタについての全てのルールをグループする必要も無い。

  * Each inductive rule is specified by a polymorphic function,
    checked by the SML type system, mapping type(s) corresponding to
    the type constructor's arguments to a value of the desired type.
	各帰納ルールは多相関数によって特定され、SML型システムによって検査され、
	型コンストラクタの引数に対応する型を望ましい型の値へマッピングする。

    An inductive rule for a tiv may refer to the same tiv, other tivs,
    both, or neither.
	あるtivの帰納ルールは同じtiv、他のtiv、両方、あるいはどちらでもないを参照しえる。

	This is done by applying the necessary tivs to
    the supplied types in the body of the rule.
	これは必要なtivをそのルールのbody部内で提供された型に適用することでなされる。

	For example, the equality rule for options is as follows.
	例えば、optionの等値性規則は以下のようになる。

      val rule: 'a Type.t -> 'a option * 'a option -> bool =
         fn t =>
         let
            val eltEquals = equals t
         in
            fn (NONE, NONE) => true
             | (SOME x, SOME y) => eltEquals (x, y)
             | _ => false
         end

  * The infrastructure automatically applies the inductive rules to
    build a tiv indexed at a particular type.
	インフラは特定の型でインデックスされた tiv を構築するために帰納ルールを自動的に適用する。

  * Different tivs can be combined and used at the same type index.
    異なるtivは同じ型インデックスついて結合して使うことが出来る。

  * Because the sets of tivs and type constructors are open and the
    inductive rules can be defined anywhere (or not at all), it is
	tivと型コンストラクタの集合はオープンかつ帰納規則はどこでも定義出来る。

    dynamically checked whether the application of a tiv to a type succeeds.
	それは型へのtivの適用が成功したかどうかは動的に検査される。

	If needed, one can layer phantom witnesses on top to
    statically ensure safety.
	もし必要であれば、phantom witnessによって静的に安全性を保証する 事が出来る。

  * The application of a tiv to a type is staged so that one can
    cache the application of the inductive rules and so that one can
    get early (dynamic) warning if a tiv is not defined for a
    particular type.
	tivの型への適用はステージされる（？）そのため、帰納ルールの適用はキャッシュ出来る
	したがって、特定の型についてtivが定義されていない場合(動的な)警告がでるかも知れない。

  * Because rules can be defined anywhere, it is dynamically checked
    whether there have been multiple definitions of a rule for the
    same tiv and type constructor.
	ルールはどこでも定義出来るため、
	同じ tiv と型コンストラクタのための、ある型について複数の定義がなされているかが動的に検査される。

  * The implementation of tivs uses an extensible universal type
    underneath.
	tivの実装は表面化に拡張可能ユニバーサル型を使用する。
	
	The only uses of a universal type use constant-time wrap and unwrap functions.
	ユニバーサル型の使用は定数時間のwrap/unwrap関数を使うだけである。

  * The implementation is portable SML and uses no unsafe features or
    extensions.
	実装はポータブルなSMLであり、かつunsafeや拡張を使っていない。

Below is an overview of how tivs are defined and used.
以下はどのようにtivが定義され、使用されるかの概要である。

Attached to this note is a tgz with complete code for the implementation, all of
the examples, and more.
このノートに添付したのは実装の完全なコードと例の全て、その他のtgzである。

------------------------------------------------------------
Using Type-Indexed Values
------------------------------------------------------------

Clients of tivs need to understand the following modules that are
exposed by the library.
tivのクライアントはライブラリの公開する以下のモジュールを理解する必要がある。

::
  structure Type: sig type 'a t end
  signature TYCON<n>
  signature TIV

The Type structure declares the SML type whose values represent SML types.
Type structure は SML型を表す値を持つSML型を定義する。

There is a different TYCON<n> for each arity of type constructor.
型コンストラクタの各アリティのための TYCON<n> がある。

For each SML type constructor (bool, option, list, ->,
etc.), one defines a representation of that type constructor as an SML
structure matching a TYCON<n> signature of appropriate arity.
各SML型コンストラクタ(bool, option, list, ->, etc.)について、
ある 適切なアリティの TYCON<n> signature にマッチするSML structureとして
その型コンストラクタの表現を定義する。（？）

So, there will be structures like
よって、以下のようなstructureがあるだろう。

::
  structure BoolTycon: TYCON0
  structure IntTycon: TYCON0
  structure ListTycon: TYCON1
  structure OptionTycon: TYCON1
  structure ArrowTycon: TYCON2

Each TYCON signature specifies the SML type constructor it represents
and an SML value that represents the type constructor, allowing one to
construct representations of types built by the type constructor.
各TYCON signatureはSML型コンストラクタと型コンストラクタを表現するSMLの値を特定し、(？)
型コンストラクタによって型の表現を構成することを可能にする。

::
  signature TYCON0 =
     sig
        type t
        ...
        val ty: t Type.t
     end
  
  signature TYCON1 =
     sig
        type 'a t
        ...
        val ty: 'a Type.t -> 'a t Type.t
     end
  
  signature TYCON2 =
     sig
        type ('a1, 'a2) t
        ...
        val ty: 'a1 Type.t * 'a2 Type.t -> ('a1, 'a2) t Type.t
     end

Every SML type is uniquely represented by applying the
type-constructor representations.
全てのSML型は型コンストラクタ表現の適用によって一意に表現される。

For example, "bool -> int option" is represented by
例えば、"bool -> int option" は以下のように表現される。

::
  val t: (bool -> int option) Type.t =
     ArrowTycon.ty (BoolTycon.ty, OptionTycon.ty IntTycon.ty)

Each tiv is represented by a structure matching the TIV signature,
whose key component is an "apply" function that applies the tiv to a
type to yield an ordinary value.
各 tiv は ``TIV`` signature にマッチする structure によって表現され、
そのキーとなる部分は通常の値を得るためにそのtivを型に適用する ``apply``  関数である。

::
  signature TIV =
     sig
        type 'a t
        ...
        val apply: 'a Type.t -> 'a t
     end

Here are some standard tivs.
以下がいくつかの標準的な tiv である。

::
  structure Dummy: TIV where type 'a t = 'a
  structure Equals: TIV where type 'a t = 'a * 'a -> bool
  structure Flatten: TIV where type 'a t = 'a -> int list
  structure Show: TIV where type 'a t = 'a -> string
  structure SuperReverse: TIV where type 'a t = 'a -> 'a
  structure Taut: TIV where type 'a t = 'a -> bool

Note that Equals, Flatten, SuperReverse, and Taut are partial,
i.e. not defined for all types, but that this is not reflected in
their types.
``Equals``, ``Flatten``, ``SuperReverse``, ``Taut`` は *partial* である、
つまり、全ての型について定義されていないが、これはそれらの型に反映されていない。

To use a tiv, one simply applies it to the representation of the
desired type.
tiv を使用するには、単にそれを望みの型の表現に適用する。

::
  val _: int option = Dummy.apply (Option.ty Int.ty)
  val _: int list * int list -> bool = Equals.apply (List.ty Int.ty)
  val _: int list list -> int list = Flatten.apply (List.ty (List.ty Int.ty))
  val _: bool -> bool -> bool =
     Taut.apply (Arrow.ty (Bool.ty, Arrow.ty (Bool.ty, Bool.ty)))
  val _: 'a Type.t -> 'a -> int list =
     fn ty => Flatten.apply ty o SuperReverse.apply ty

The last example is the one from
最後の例は以下に由来する。

  http://mlton.org/References#Yang98

showing why one wants to be able to compose different tivs dealing
with the same type family.
なぜ同じ型族に取り組む（？）異なる tiv を組み合わせることを可能にしたいのかを示している。


------------------------------------------------------------
Declaring Type-Indexed Values
------------------------------------------------------------

One declares a new tiv by applying the Tiv functor.  The inductive
rules are specified later.
新たな tiv を Tiv functor を適用することで定義する。
帰納ルールは以下で示される。

::
  functor Tiv (S: TIV_ARG): TIV

  signature TIV_ARG =
     sig
        type 'a t
           
        val iso: ('a, 'b) Iso.t -> ('a t, 'b t) Iso.t
        val name: string
     end

Type 'a t specifies the type of the type-indexed value once the
type-index has been instantiated.
型 *'a t* はtype-indexがインスタンス化された時点の type-indexed value の型を示す。

For example, for equality,
例えば等値性については

::
   type 'a t = 'a * 'a -> bool

The name is used solely for debugging messages.
``name`` はデバッグメッセージに使われる。
The "iso" function tells how to lift an arbitrary isomorphism to an isomorphism between values.
``iso`` 関数は任意の isomorphism から値間のisomorphismへどのように持ち上げるのかを示す。

An isomorphism is a pair of functions, one for each direction of the mapping.
isomorphism は関数のペアであり、写像の各向きに対応する。

::
  structure Iso:>
     sig
        type ('a, 'b) t
  
        val inject: ('a, 'b) t * 'a -> 'b
        val make: ('a -> 'b) * ('b -> 'a) -> ('a, 'b) t
        val project: ('a, 'b) t * 'b -> 'a
        ...
     end

Here is how the Dummy type-indexed value is declared.
これは ``Dummy`` type-indexed value がどのように定義されるかを示す。

::
  structure Dummy =
     Tiv (type 'a t = 'a
          val name = "dummy"
          fun iso i = i)

Here is how Equals is declared.  The isomorphism lifter uses some
straightforward utilities from the Iso structure.
これは ``Equals`` がどのように定義されるか。
isomorphism リフターは ``Iso`` structure のいくつかの簡単なユーティリティを使う。

::
  structure Equals =
     Tiv (type 'a t = 'a * 'a -> bool
          val name = "equals"
          fun iso i = let open Iso in arrow (tuple2 (i, i), id) end)

At the point a tiv is declared, it is undefined for all types.
tiv が定義されるポイントでは、それは全ての型について未定義である。

Later definitions of inductive rules determine the types at which the tiv is defined.
後述する(?) 帰納ルールの定義はどのtivが定義されているかを決定する。

------------------------------------------------------------
Defining Nullary Type Constructors and Rules
------------------------------------------------------------

The library defines a functor, Tycon0, for building nullary type constructors.
ライブラリがfunctor ``Tycon0`` をnullary型コンストラクタの構築のために定義する。

::
  functor Tycon0 (S: TYCON0_ARG): TYCON0

  signature TYCON0_ARG =
     sig
        type t

        val name: string
     end

For example, the bool type constructor is created by the following
functor application, supplying the SML type being represented and the
name, used only for debugging messages.
例えば bool 型コンストラクタは以下のファンクタ適用で作られる。
これは表現されたSML型が提供され、 ``name`` はデバッグメッセージの為のみに使用される。

::
  structure BoolTycon = Tycon0 (type t = bool
                                val name = "bool")

The library provides a family of functors, DefCase<n>, for defining
inductive rules, one for each arity.
ライブラリは functor ``DefCase<n>`` 族を各アリティのために帰納ルールを定義するために提供する。

The functor for defining the
rule for nullary type constructors is specified by the following.
そのnullary型コンストラクタの定義のためのファンクタは以下によって示される。

::
  signature EMPTY = sig end
  functor DefCase0 (structure Tycon: TYCON0
                    structure Value: TIV
                    val rule: Tycon.t Value.t): EMPTY

The EMPTY signature is used for modules that have no exports.
``EMPTY`` シグネチャは何も公開しないモジュールのために使用される。

All of the DefCase<n> functors return an empty structure.
全ての ``DefCase<n>`` ファンクタは空のstructureを返す。

That is, they are
functors that are applied purely for their side effect, namely, adding
an inductive rule to the global collection of rules.  
それは、それらは純粋に、名前付け、規則のグローバルコレクションへ帰納ルールの追加、サイドエフェクトのために適用されるからだ。

Here are the definitions of the rules for booleans for the Dummy and
Equals tivs.
これは ``Dummy`` と ``Equals`` tiv のためのbooleanのための規則の定義である。

::
  structure Z = DefCase0 (structure Tycon = BoolTycon
                          structure Value = Dummy
                          val rule = false)

  structure Z = DefCase0 (structure Tycon = BoolTycon
                          structure Value = Equals
                          val rule = op =)

The definition of equality uses SML's built-in polymorphic equality
specialized for the particular case of booleans.
等値性の定義はbooleanの特定ケースにスペシャライズされたSMLの組み込みの多相等値性を使う。

One could just as well have written
？？？

::
  val rule = fn (false, false) => true 
              | (true, true) => true 
              | _ => false

------------------------------------------------------------
Defining Non-nullary Type Constructors and Inductive Rules
------------------------------------------------------------

The library provides a family of functors for defining the
representations of type constructors, one for each arity.
ライブラリは各アリティのための型コンストラクタの表現を定義するためのファンクターの族を提供する。

::
  functor Tycon<n> (S: TYCON<n>_ARG): TYCON<n>

A new type constructor of arity <n> is defined by applying Tycon<n> to
appropriate arguments.
新たなアリティ<n>の型コンストラクタは ``Tycon<n>`` を適切な引数に適用することで定義される。

Non-nullary type constructors are more complicated than nullary ones.
非nullary型コンストラクタはnullaryのそれより複雑である。

Before showing the most general case,
I'll show two common special cases, provided as functors and
implemented using the more general Tycon<n> functors.
最も一般的な場合を示す前に、ファンクタとして提供され、より一般的な ``Tycon<n>`` ファンクタを使用して実装される2つの一般的な特殊ケースを示す。

The simplest kind of type constructor is one that is immutable and not
defined recursively (e.g. option).  These can be defined by the
最も単純な種類の型コンストラクタは immutable かつ非再帰的(例えば option)。
Tycon<n>Simple family of functors.
これらは ``Tycon<n>Simple`` ファンクタファミリーによって定義される。

::
  functor Tycon<n>Simple (S: TYCON<n>_SIMPLE_ARG): TYCON<n>_SIMPLE

  signature TYCON<n>_SIMPLE_ARG =
     sig
        type ('a1, ..., 'a<n>) t
         
        val iso: ('a1, 'b1) Iso.t * ... * ('a<n>, 'b<n>) Iso.t
                 -> (('a1, ..., 'a<n>) t, ('b1, ..., 'b<n>) t) Iso.t
        val name: string
     end

Tycon<n>Simple is passed the SML type constructor being represented
and a name used for debugging.
``Tycon<n>Simple`` はSML型コンストラクタに渡され表現され、nameがデバッグに使われる。

Additionally, one must supply a way to
lift a product of isomorphisms, one for each type argument, to an
isomorphism on the constructed type.
さらに、各型引数について、isomorphismsの直積を構成された型上のisomorphismへ持ち上げる方法を提供しなければならない。

The result of Tycon<n>Simple is a specialized version of TYCON<n>.
``Tycon<n>Simple`` の結果は ``TYCON<n>`` を特化したものである。？？

For example, here is how the option type constructor is represented.
例えば、これは ``option`` 型コンストラクタがどのように表現されるかである。

::
  structure OptionTycon =
     Tycon1Simple (type 'a t = 'a option
                   fun iso i =
                      let
                         fun map f =
                            fn NONE => NONE
                             | SOME x => SOME (f (i, x))
                      in
                         Iso.make (map Iso.inject, map Iso.project)
                      end
                   val name = "option")

The library provides a family of functors, DefCase<n>Simple, for defining
inductive rules for simple type constructors.
ライブラリはファンクタ族、 ``DefCase<n>Simple`` を単純な型コンストラクタの機能ルールを定義するために提供する。

::
  functor DefCase<n>Simple
     (S: sig
            structure Tycon: TYCON<n>_SIMPLE
            structure Value: TIV
            val rule: 'a1 Type.t * ... * 'a<n> Type.t 
                      -> ('a1, ..., 'a<n>) Value.t
         end): EMPTY

Here are the inductive rules for the option type constructor for the
Dummy and Equals tivs.
これは ``Dummy`` と ``Equals`` tiv のための ``option`` 型コンストラクタのための帰納ルールである。

::
  structure Z = DefCase1Simple (structure Tycon = OptionTycon
                                structure Value = Dummy
      	                        val rule: 'a Type.t -> 'a option =
                                   fn t => SOME (Dummy.apply t))
  structure Z = 
     DefCase1Simple 
     (structure Tycon = OptionTycon
      structure Value = Equals
      val rule: 'a Type.t -> 'a option * 'a option -> bool =
         fn t =>
         let
            val eltEquals = Equals.apply t
         in
            fn (NONE, NONE) => true
             | (SOME x, SOME y) => eltEquals (x, y)
             | _ => false
         end)

Type constructors that define recursive types (e.g. list) need a
slightly more complex definition, using the Tycon<n>Iso family of
functors.
再帰型(例えば ``list`` )を定義する型コンストラクタはわずかに複雑な定義を必要とし、
ファンクタ ``Tycon<n>Iso`` 族を使用する。


::
  functor Tycon<n>Iso (S: TYCON<n>_ISO_ARG): TYCON<n>_ISO

  signature TYCON<n>_ISO_ARG =
     sig
        structure R:
           sig
              type ('a1, ..., 'a<n>, 'r) t
  
              val iso:
                 ('a1, 'b1) Iso.t * ... * ('a<n>, 'bn) Iso.t * ('ra, 'rb) Iso.t
                 -> (('a1, ..., 'a<n>, 'ra) t, ('b1, ..., 'b<n>, 'rb) t) Iso.t
           end
  
        type ('a1, ..., 'a<n>) t

        val isorec: unit -> (('a1, ..., 'a<n>, ('a1, ..., 'a<n>) t) R.t,
                             ('a1, ..., 'a<n>) t) Iso.t
        val name: string
     end

The code uses the idea of recursion schemes:

  http://mlton.org/References#WangMurphy

The idea is that R.t is a non-recursive representation of the type,
where its last type argument corresponds to recursive uses.
アイデアは、 ``R.t`` は型の非再帰表現であり、ここでその最後の片引き数は再帰的な使用に対応する。

The isorec function gives the (trivial) isomorphism between the type and
its recursion scheme.
``isorec`` 関数は、その型とそのリカージョンスキームの間の(自明な) isomorphismを与える。

For example, here is how the list type constructor is represented.
例えば、これは ``list`` 型コンストラクタがどのように表されるかである。

::
  structure ListTyconRep =
     struct
        datatype ('a, 'r) t =
           Cons of 'a * 'r
         | Nil
  
        fun iso (ia, ir) =
           let
              fun map (fa, fr) =
                 fn Cons (a, r) => Cons (fa (ia, a), fr (ir, r))
                  | Nil => Nil
           in
              Iso.make (map (Iso.inject, Iso.inject),
                        map (Iso.project, Iso.project))
           end
     end
  
  structure ListTycon =
     Tycon1Iso
     (structure R = ListTyconRep
      type 'a t = 'a list
      val name = "list"
      fun isorec () = 
         Iso.make (fn R.Cons (x, l) => x:: l | R.Nil => [],
                   fn [] => R.Nil | x :: l => R.Cons (x, l)))

The datatype ListTyconRep.t is exposed because the definition of an
inductive rule for a list will deal with that representation rather
than the native list representation.
``datatype ListTyconRep.t`` が公開されているのは、リストについての機能ルールの定義が
ネイティブリスト表現よりむしろ表現に取り組むだろう…？？？

The library provides a family of functors, DefCase<n>Iso, for defining
inductive rules for such type constructors.
ライブラリはファンクタ族、 ``DefCase<n>Iso`` をそのような型コンストラクタの機能ルールの定義のために提供する。

::
  functor DefCase<n>Iso
     (structure Tycon: TYCON<n>_ISO
      structure Value: TIV
      val rule: 'a1 Type.t * ... * 'a<n> Type.t 
                * (('a1, ..., 'a<n>, 'b) Tycon.R.t, 'b) Iso.t
                -> 'b Value.t): EMPTY

For example, here are the inductive rules for the list type
constructor for the Dummy and Equals tivs.
例えば、これは ``list`` 型コンストラクタの ``Dummy`` と ``Equals`` tiv のための帰納ルールである。

::
  structure Z =
     DefCase1Iso
     (structure Tycon = ListTycon
      structure Value = Dummy
      fun rule (t, i) =
         Iso.inject (i, Cons (Dummy.apply t, Iso.inject (i, Nil))))
  
  structure Z =
     DefCase1Iso
     (structure Tycon = ListTycon
      structure Value = Equals
      fun rule (t, i) =
         let
            val elt = Equals.apply t
         in
            fn z =>
            recur (z, fn ((b1, b2), loop) =>
                   case (Iso.project (i, b1), Iso.project (i, b2)) of
                      (Nil, Nil) => true
                    | (Cons (x1, b1), Cons (x2, b2)) =>
                         elt (x1, x2) andalso loop (b1, b2)
                    | _ => false)
         end)

Mutable types can not be represented via an isomorphism since that
would lose the sharing that is essential to mutability.
mutable type は isomorphism では表現出来ない mutability にとって必須である共有を失うためである。

For mutable types we need a generalization of recursion schemes in which the type
constructor is represented by an abstract type, typically a record of
operations, that can be wrapped by isomorphisms.
mutable typeのためには、型コンストラクタが抽象型、伝統的には操作のレコード、これは isomorphism でラップ出来る、
で表現される recursion scheme の一般化が必要？？？

::
  functor Tycon<n> (S: TYCON<n>_ARG): TYCON<n>

  signature TYCON<N>_ARG =
     sig
        structure Rep:
           sig
              type ('a1, ..., 'a<n>, 'b) t
           end
  
        type ('a1, ..., 'a<n>) t
           
        val makeRep: ('a1, 'b1) Iso.t
                     * ...
                     * ('a<n>, 'b<n>) Iso.t
                     * (('a1, ..., 'a<n>) t, 'c) Iso.t 
                     -> ('b1, ..., 'b<n>, 'c) Rep.t
        val name: string
     end

To apply functor Tycon<n>, in addition to specifying the underlying
SML type constructor (t) and the debugging name, one also specifies a
representation (Rep.t) of values of the type and a way to create a
representation (makeRep) from isomorphisms on each of the type
arguments and an isomorphism on the type itself.  
ファンクタ ``Tycon<n>`` を適用するには、下層のSML型コンストラクタ ``t`` とデバッグ名に加えて、
その型の値の表現 ``Rep.t`` と各型引数上での isomorphism とその型自身の isomorphism から表現 ``makeRep`` を作る方法も指定する。

For example, here is how SML's "ref" type constructor is implemented.
例えば、これは SMLの ``ref`` 型コンストラクタが実装される。

::
  structure RefRep =
     struct
        datatype ('a, 'b) t =
           T of {get: 'b -> 'a, 
                 equals: 'b * 'b -> bool,
                 make: 'a -> 'b,
                 set: 'b * 'a -> unit}
     end

  structure RefTycon =
     Tycon1
     (structure Rep = RefRep
      type 'a t = 'a ref
      val name = "ref"
      fun makeRep (ix, ir) =
         RefRep.T
         {get = fn r => Iso.inject (ix, ! (Iso.project (ir, r))),
          equals = (fn (r, r') =>
                    (Iso.project (ir, r) = Iso.project (ir, r')
                    handle _ => false)),
          make = fn x => Iso.inject (ir, ref (Iso.project (ix, x))),
          set = fn (r, x) => Iso.project (ir, r) := Iso.project (ix, x)})

The idea is that RefRep provides a "generic" implementation of ref
cells, where 'a is the representation of the element and 'b is
representation of the cell.
アイデアは ``RefRep`` がrefセルの "一般的な" 実装を提供し、ここで ``'a`` が要素の表現かつ ``'b`` がセルの表現である。

makeRep show how to use the underlying SML primitives to build the generic representation, given the
isomorphism on the underlying elements (ix) and the isomorphism on ref cells (ir).
``makeRep`` は下層のSMLプリミティブを使用して一般的な表現を構築する方法を示し、
下層要素(ix)上のisomorphismとrefセル(ir)のisomorphismが与えられる。


The fully general DefCase<n> functors have the following form.
完全に一般化した ``DefCase<n>`` ファンクタは以下のような形になる。

::
  functor DefCase<n>
     (structure Tycon: TYCON<n>
      structure Value: TIV
      val rule: 'a1 Type.t * ... * 'a<n> Type.t
                * ('a1, ..., 'a<n>, 'b) Tycon.Rep.t
                * ('b, Univ.t) Iso.t
                -> 'b Value.t)): EMPTY

The idea is that, as before, a rule takes each of the type arguments
and can use them inductively as it wishes.
アイデアは、既に述べたように、各型引数を受け取り望むように帰納的に使うことが出来る？？？

In addition, the rule receives the generic representation of values and must produce an
instance of the tiv, 'b Value.t, that operates on that representation.
加えて、その規則は値の一般表現を受け取り、その表現上で操作する（？）その tiv、 ``'b Value.t`` のインスタンスを生成しなければならない。？？？


For example, here are the inductive rules for the ref type constructor
for the Dummy and Equals tivs.
例えば、これは ``Dummy`` と ``Equals`` tivのためのref型コンストラクタのための帰納規則である。

::
  structure Z =
     DefCase1
     (structure Tycon = RefTycon
      structure Value = Dummy
      fun rule (t, RefRep.T {make, ...}, _) = make (Dummy.apply t))
            
  structure Z =
     DefCase1
     (structure Tycon = RefTycon
      structure Value = Equals
      fun rule (_, RefRep.T {equals, ...}, _) = equals)

In DefCase<n> functors, the third argument to the rule, of type ('b,
Univ.t) Iso.t, gives the rule access to an embedding of the value in a
universal type.
``DefCase<n>`` ファンクタ内では、規則への第3引数、('b, Univ.t) Iso.t、
universal 型の値の埋め込みへのアクセスを与える。？？

This is useful for tivs like Show, which need to keep
a container holding values of different types.
これは ``Show`` のような tiv に便利です。
これは異なる型の値を保持するコンテナを維持するために必要。

Sometimes it is useful to define a default case for a tiv.  This is
easily done using the DefDefault functor.
時々、tiv にデフォルトケースを定義するのは便利である。
これは ``DefDefault`` ファンクタを使うことで容易に行うことが出来る。

::
  functor DefDefault (structure Value: TIV
                      val rule: 'a Type.t -> 'a Value.t): EMPTY

The default case will then be used for any type constructor that
doesn't have a rule defined for the tiv.
デフォルトケースはその tiv のために定義された規則を持たないどんな型コンストラクタのためにも使用されるだろう。

------------------------------------------------------------
The Variable-Arity Tuple Type Constructor
------------------------------------------------------------

The library defines functions for building representations of tuple
types of different arities.
ライブラリは異なる引数のタプル型の表現を構築する関数を定義する。

::
  val ty<n>: 'a1 Type.t * ... * 'a<n> Type.t -> ('a1 * ... * 'a<n>) Type.t

The tuple type-constructor in SML can either be viewed a family of
type constructors (two-tuple, three-tuple, etc.) or as a single variable-arity type constructor.
SMLのタプル型コンストラクタは(2-タプル、3-タプル、他)の型コンストラクタ族または単一の可変アリティ型コンストラクタのどちらとも見なすことが出来る。

The latter view is much more convenient for the purpose of defining tivs.
後者の視点はtivを定義する目的に置いてははるかに便利である。

The library defines a functor, DefTupleCase, that allows one to give a single rule that
defines how a tiv should behave for tuples of any arity.
ライブラリは、任意のアリティのタプルのためにどのようにtivが振る舞うべきかを定義する単一規則を与えることを許す ``DefTupleCase`` ファンクタ を定義する。

::
  functor DefTupleCase
     (structure Accum:
         sig
            type 'a t
  
            val iso: ('a, 'b) Iso.t -> ('a t, 'b t) Iso.t
         end
      structure Value: TIV
      val base: unit Accum.t
      val finish: 'a Accum.t -> 'a Value.t
      val step: 'a Type.t * 'b Accum.t -> ('a * 'b) Accum.t): EMPTY

The idea is that DefTupleCase is doing a fold over the components of
the tuple type, starting with a "base" accumulator, building the
accumulator with "step", and converting the accumulator to a value of
the right type with "finish".
アイデアは ``DefTupleCase`` はタプル型の要素上で畳み込みを行う、*base* アキュムレータから始め、
*step* によってアキュムレータを構築し、*finish* によってアキュムレータを正しい型の値に変換する。

Here are the definitions of the rules for tuples for the Dummy and Equals tivs.
これが ``Dummy`` と ``Equals`` tivのタプルについての規則の定義である。

::
  structure Z =
     DefTupleCase
     (structure Accum = Dummy
      structure Value = Dummy
      val base = ()
      val finish = id
      fun step (t, ac) = (Dummy.apply t, ac))
  
  structure Z =
     DefTupleCase
     (structure Accum = Equals
      structure Value = Equals
      fun base _ = true
      val finish = id
      fun step (a, equalsR) =
         let
            val equalsA = Equals.apply a
         in
            fn ((a1, r1), (a2, r2)) =>
            equalsA (a1, a2) andalso equalsR (r1, r2)
         end)

Those rules don't need the accumulator.  For an example that does, see
the rule for Show in the full code.
それらの規則はアキュムレータを必要としない。
それを行う例としてはコード内の ``Show`` の規則をみよ。

------------------------------------------------------------
Partial tivs and Witnesses
------------------------------------------------------------

Because type constructors can be added at an time, the framework does
not statically guarantee correctness of the application of a tiv to a type.
型コンストラクタは一度追加出来るため、フレームワークは tiv の型への適用の正しさを静的に保証しない。

One can uses phantom witnesses to statically ensure safety if needed.
もし必要ならphantom witnessを使うことで静的に安全性を保証出来る。

For example, tautology checking only works on types of the form
例えば、トートロジー検査は形

::
  bool -> bool -> ... -> bool

の型上でのみ動作する。

One can inductively define this type family and represent the fact
that a type is in the family with an additional type constructor, Ok.t
and two value constructors as follows.
この型族を帰納的に定義し、追加の型コンストラクタを伴う族の ある型 という事実を表現することが出来る。
``Ok.t`` と2つの値コンストラクタは以下

::
  structure Ok:
     sig
        type 'a t
  
        val bool: bool Type.t t
        val arrow: 'a Type.t t -> (bool -> 'a) Type.t t
      end

One can then constrain the partial tautology-checking tiv to represent
it safely via the following type.
部分トートロジー検証 tiv を制約してそれが安全なことを以下の型を通して表現することが出来る。

::
   val taut: 'a Type.t * 'a Type.t Ok.t -> 'a -> bool

Clients of taut are now required to prove that the supplied type is in
the required family, and hence no runtime exception can be raised.
``taut`` のクライアントは与えられた型が要求される族で、かつ従って実行時例外が投げられ得ないことを
証明されたことを要求される。

Below is the complete definition of a safe tautology tiv.
以下は安全なトートロジー tiv の完全な定義である。

This code also demonstrates the use of the arrow type constructor, as well as
giving an example of one tiv (Taut) calling another (FromBool) in a rule.
このコードはまた ルール内でもう一つ (``FromBool``) を呼ぶ tiv (``Taut``) の例を与えるのと同様に
arrow 型コンストラクタの使用の実例でもある。

::
  structure Taut:>
     sig
        structure Ok:
           sig
              type 'a t
  
              val bool: bool Type.t t
              val arrow: 'a Type.t t -> (bool -> 'a) Type.t t
           end
  
        val taut: 'a Type.t * 'a Type.t Ok.t -> 'a -> bool
     end =
     struct
        structure Ok =
           struct
              type 'a t = unit
  
              val bool = ()
              val arrow = ignore
           end
  
        structure FromBool =
           Tiv (type 'a t = bool -> 'a
                fun iso i = let open Iso in arrow (id, i) end
                val name = "fromBool")
  
        structure Z =
           DefCase0 (structure Tycon = BoolTycon
                     structure Value = FromBool
                     val rule = id)
  
        structure Taut =
           Tiv (type 'a t = 'a -> bool
                fun iso i = let open Iso in arrow (i, id) end
                val name = "taut")
  
        structure Z =
           DefCase0 (structure Tycon = BoolTycon
                     structure Value = Taut
                     val rule = id)
           
        structure Z =
           DefCase2Simple
           (structure Tycon = ArrowTycon
            structure Value = Taut
            fun rule (ta, tb) =
               let
                  val arg = FromBool.apply ta
                  val res = Taut.apply tb
               in
                  fn f => let
                             fun one b = res (f (arg b))
                          in
                             one true andalso one false
                          end
               end)
               
        fun taut (t, _) = Taut.apply t
     end

------------------------------------------------------------
Underlying Implementation
------------------------------------------------------------

The implementation of all of the modules (TYCON, TIV, Tycon<n>, Tiv,
DefCase<n>, etc.) is about 600 lines of SML code.
モジュール(``TYCON``, ``TIV``, ``Tycon<n>``, ``Tiv``, ``DefCase<n>``, etc)の全ての実装は約600行のSMLコードである。

The key module in the implementation is
実装内でキーとなるモジュールは

::
  structure RawTiv:> RAW_TIV

Here's most of the RAW_TIV signature, which provides an interface to
tivs that allows one to create new tivs, apply tivs to types, and define inductive rules.
これは ``RAW_TIV`` シグネチャのほとんどは、それが 新たな tiv を作成することを許す tiv へのインターフェースを提供する ？？？
tiv の型への適用、そして帰納規則の定義。


::
  signature RAW_TIV =
     sig
        structure Type:
           sig
              structure Raw:
                 sig
                    type t
                 end
              
              type 'a t
     
              val apply: 'a Tycon.t * Raw.t list * (('b, Univ.t) Iso.t -> 'a) 
                         -> 'b t
              val iso: 'a t -> ('a, Univ.t) Iso.t
              val make: Raw.t * ('a, Univ.t) Iso.t -> 'a t
              val raw: 'a t -> Raw.t
           end

        type 'a t

        val apply: 'a t * Type.Raw.t -> 'a
        val make: {name: string} -> 'a t
        val defCase: 'a t * 'b Tycon.t * (Type.Raw.t list * 'b -> 'a) -> unit
        val defDefault: 'a t * (Type.Raw.t -> 'a) -> unit
     end

A value of type 'a t is a tiv that produces a value of type 'a when applied.
型 ``'a t`` の値は tiv であり、適用された時に型 ``'a`` の値を生成する。

Of course, a tiv exposed to the client has a different type
depending on the type index at which it is used, e.g.
もちろん、tiv は使用された箇所でのtype indexに依存して異なる型を持つクライアントへ公開する（？）例えば：

::
   Equals.apply BoolTycon.ty: bool * bool -> bool
   Equals.apply IntTycon.ty: int * int -> bool

This is handled by storing with each type representation an
isomorphism (Type.iso) between that type and a universal type Univ.t
using the usual exn wrap/unwrap trick.
これはそれぞれの型表現について、通常 ``exn`` wrap/unwrap トリックを使うことで 型とユニバーサル型 ``Univ.t`` の間の isomorphism (``Type.iso``) を保持することで扱われる。

Then, a tiv of type 'a t is implemented as a raw tiv of type Univ.t t.
次に、 型 ``'a`` の tivは型 ``Univ.t t`` の raw tiv として実装される。

For example, underneath, the equals tiv has type
例えば、表面化では、equals tiv は型

::
   (Univ.t * Univ.t -> bool) RawTiv.t

を持つ。

The infrastructure coerces the application of a raw tiv to a value of
the appropriate type by lifting the isomorphism on the appropriate
type to an isomorphism on the value using the iso function that was
supplied by the user when defining the tiv.
インフラストラクチャは適切な型上のisomorphismを その tiv を定義する時にユーザによって提供される ``iso`` 関数を使うことで
値上のisomorphismに持ち上げることによって raw tivの適切な型の値への適用を強制する。

The trickiest part of the implementation deals with the apparent
conflict between the absence of first-class polymorphism in SML and
the need to apply the user-supplied inductive rules at any number of types.
実装の最もトリッキーなのは SMLのファーストクラスポリモーフィズムの欠如と
幾つもの型のユーザの提供した帰納的規則を提供する必要のある ことの間での明らかな衝突に取り組む部分である。

The solution involves a kind of poor-man's first-class
polymorphism in which the rules are actually only ever instantiated at
one type, Univ.t, and handle arbitrary types by dealing with
universally-wrapped representations built from the representations
supplied by the user when defining type constructors.
解決策は一種の poor-man's first-class polymorphism を実行することだ。
その規則は実質的にこれまでに1つの型 ``Univ.t`` のみでインスタンス化され、
型コンストラクタを定義する時にユーザに提供された表現から構築された universally-wrapped 表現
に取り組むことで 任意の型を扱う。

See def-case.fun in the implementation for details -- that code makes it
clear that the use of functors to require that rules be polymorphic is
an illusion (albeit a very useful one).
詳細は実装内の ``def-case.fun`` を参照して下さい -- そのコードは分かるように説明する
ファンクタの使用は 規則が多相になることを要求する ことはイリュージョン（？）

Raw tivs themselves are deceptively simple.
Raw tiv 自身は 実は単純である。

The keep a list ref with one element (a function) for each type constructor that has a rule.
1つの規則を持った各型コンストラクタの1つの要素(関数)を伴うref リストを維持する？？？

DefCase simply pushes a rule on the list, after checking that no rule
is already defined.
``DefCase`` は既に規則が定義されていないかを検証した後に、そのリストに単純にプッシュする。

Application of a raw tiv to a type looks up the
correct rule in the list and applies the associated rule.
raw tiv の型への適用はリスト内で正しい規則を調べ、かつ関連する規則を適用する。


------------------------------------------------------------
Related Work: Yang98
------------------------------------------------------------

  http://mlton.org/References#Yang98

describes two styles of tivs in SML: value dependent and value
independent.  In short, with the value-dependent style, for each tiv
one creates a new family of type indexes where each type index is the
tiv at the corresponding type.  This is the style (currently) used on

  http://mlton.org/TypeIndexedValues

and in Vesa's recent note expanding on the idea in Yang98 showing how
to use products of tivs so that one can use the same family of types
for multiple tivs.

  http://mlton.org/pipermail/mlton-user/2006-August/000907.html
 
In the value-independent style, one uses a single family of types and
allows as many tivs as one wants to be defined for the family.  This
is a superior approach to the value-dependent approach because it
easier to add new tivs and because tivs are automatically composable
-- one isn't forced to collect together the tivs into a product.

Yang98 describes two approaches to implementing value-independent
tivs.  The first approach requires first-class and higher-order
polymorphism and is expressed using an extension of the SML module
system.  The second approach implements tivs by converting values to a
specially constructed universal type, running an ordinary recursive
SML function on the universal type, and then converting back. The
approach described in this note is roughly similar to Yang's first
approach, in that one defines rules by polymorphic functions and
(seemingly) passes them around to be used at different types.  The
main improvement of this note is that the implementation is in
ordinary SML and is achieved through a combination of by using
universal wrappers, recursion-scheme-like encoding tricks, and
illusory functors.

Yang's second approach also uses universal wrappers, but the
similarity with the use of universals in this note is superficial.
Yang requires a single mutually recursive datatype definition of the
universal type, while in this note, the universal type is extensible
and is not specified in any one place.  Yang's approach requires the
user to define a different universal type for each type family, and
doesn't allow the addition of new type constructors in a modular way.
This note uses a single type family and allows the definitions of
tivs, type constructors, and rules to occur anywhere at top level.
Yang's approach also uses deep coercion functions between ordinary SML
values and values of his universal type, which take time proportional
to the size of the data structure being coerced. This is inefficient
and doesn't work with mutable values.  This note uses only
constant-time wrappers and unwrappers, and handles mutable values
smoothly.

------------------------------------------------------------
Future Work
------------------------------------------------------------

The ideas in this note may solve the problem with embedding datatypes
that Benton encountered in "Embedded Interpreters"

  http://mlton.org/References#Benton05

The ideas also give me more confidence that we will be able to build
specialized interpreters with MLton that are able to expose host
polymorphic functions to the interpreter, while maintaining full speed
of the host code.  The trick this note uses to wrap up polymorphic
functions in a universal type, while retaining their ability to apply
to values of different types (appropriately wrapped and represented)
seems like it may be just the thing to do automatically when building
the specialized interpreter.

-------------- next part --------------
A non-text attachment was scrubbed...
Name: tiv.tgz
Type: application/octet-stream
Size: 10168 bytes
Desc: not available
Url : http://mlton.org/pipermail/mlton-user/attachments/20060928/adfc123d/tiv-0001.obj

    Previous message: [MLton-user] profiling timer expired?
    Next message: [MLton-user] a new approach to type-indexed values in SML
    Messages sorted by: [ date ] [ thread ] [ subject ] [ author ]

More information about the MLton-user mailing list
